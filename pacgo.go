package main

import (
	"fmt"
	"os"
	"path/filepath"
)

// Cmd represents a command. Duh.
type Cmd struct {
	// Help is the help line for the command. Duh.
	Help string

	// Run is the function that is called when the command is run.
	// The first arg is the command's name that it was registered
	// with, much like how command-line arguments work.
	Run func(...string) error
}

// The registered commands.
var cmds map[string]*Cmd

// RegisterCmd registers the given command for the given arg.
func RegisterCmd(arg string, cmd *Cmd) {
	if cmds == nil {
		cmds = make(map[string]*Cmd)
	}

	cmds[arg] = cmd
}

var (
	// The temporary directory for building AUR packages. Usually
	// /tmp/(arg0)-(uid)
	TmpDir string
)

// MkTmpDir creates a new temporary directory for the given package
// as a subdirectory of TmpDir. It returns the full path of the new
// dir and an error, if any. Note that it always returns the path the
// new dir would have had, even if it fails to create it.
func MkTmpDir(name string) (string, error) {
	tmp := filepath.Join(TmpDir, name)
	err := os.MkdirAll(tmp, 0755)
	if err != nil {
		return tmp, fmt.Errorf("Failed to create %v.", tmp)
	}

	return tmp, nil
}

// Usage prints the usage. Not particularly surprising.
func Usage() {
	fmt.Printf("Usage: %v <cmd> [options]\n", os.Args[0])
	fmt.Println("Commands:")
	for name, cmd := range cmds {
		fmt.Printf("  %v: %v\n", name, cmd.Help)
	}
}

// UsageError represents an error generated by detecting a bad
// argument. Returning one all the way up to main will cause the
// usage to be printed after the error message.
type UsageError struct {
	Arg string
}

func (err UsageError) Error() string {
	return fmt.Sprintf("Unknown argument: %v", err.Arg)
}

var (
	// Whether or not development package updates should be forced.
	//
	// TODO: Implement this.
	UpdateDevel bool
)

func main() {
	if os.Getuid() == 0 {
		Cprintf("[c7]error:[ce] Can't run as root.\n")
		os.Exit(1)
	}

	if len(os.Args) == 1 {
		Usage()
		os.Exit(2)
	}

	switch os.Args[1] {
	case "-h", "-help", "--help":
		Usage()
		os.Exit(0)
	}

	TmpDir = filepath.Join(os.TempDir(), fmt.Sprintf("%v-%v", filepath.Base(os.Args[0]), os.Getuid()))
	err := os.MkdirAll(TmpDir, 0755)
	if err != nil {
		Cprintf("[c7]error:[ce] Failed to create %v.", TmpDir)
		os.Exit(1)
	}

	if cmd, ok := cmds[os.Args[1]]; ok {
		err := cmd.Run(os.Args[1:]...)
		if err != nil {
			Cprintf("[c5]%v: [c7]error:[ce] %v\n", os.Args[1], err)
			if _, ok := err.(UsageError); ok {
				Usage()
				os.Exit(2)
			}
			os.Exit(1)
		}
	} else {
		Cprintf("[c7]error:[ce] No such command: [c5]%v[ce]\n", os.Args[1])
		Usage()
		os.Exit(2)
	}
}
